package notes;

/**
 *
 * 设计模式分为三种类型，共23种
 *    1、创建型模式：单例模式、抽象工厂模式、原型模式、建造者模式、工厂模式
 *    2、结构型模式：适配器模式、桥接模式、组合模式、外观模式、享元模式、代理模式、装饰者模式
 *    3、行为型模式：模板方法模式、命令模式、访问者模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略
 *    模式、职责链模式
 *
 *    单例模式注意事项和细节说明
 *        1、单例模式保证了系统内存中只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高
 *        系统性能。
 *        2、当想实例化一个单例类的时候，必须记住使用相应的获取对象的方法，而不是使用new
 *        3、单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多，但又经常使用的对象、
 *        工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）
 *    单例设计模式介绍：所谓类的单例设计模式就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且
 *    该类只提供一个取得其对象实例的方法（静态方法）。
 *    比如Hibernate的SessionFactory，它充当数据存储源的代理，并负责创建session对象，SessionFactory并不是轻量级的，
 *    一般情况下，一个项目通常只需要一个SessionFactory就够了，这时就会使用单例模式。
 *
 *   工厂模式分为简单工厂模式、工厂方法模式和抽象工厂模式
 *    简单工厂模式：
 *        基本介绍：
 *            1、简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品的实例，
 *            简单工厂模式工厂模式家族中最简单实用的模式
 *            2、简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）
 *            3、在软件开发中。当我们会用到大量的创建某种、某类或者某批对象时，就会使用工厂模式
 *    工厂方法模式：
 *        1、工厂方法模式设计方案：将披萨项目的实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现
 *        2、工厂方法模式：定义一个创建对象的抽象方法，由子类决定要实例化的类，工厂方法模式将对象的实例化推迟到子类。
 *
 *    抽象工厂模式：
 *        1、抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。
 *        2、抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合
 *        3、从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象）。
 *        4、将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类，程序员可以根据创建对象类型使用相应的工厂子类。
 *        这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。
 *
 *   工厂模式小结：
 *        1、工厂模式的意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。
 *        从而提高项目的扩展和维护性。
 *        2、设计模式的依赖抽象原则：
 *            1.创建对象实例时，不要直接new类，而是把这个new类的动作放在一个工厂的方法中，并返回，
 *            2.不要让类继承具体类，而是继承抽象类或者实现接口
 *            3.不要覆盖重写基类中已经实现的方法。
 *    简单工厂模式优缺点以及应用场景
 *        1、优点：
 *            1.实现了对象创建和使用的分离(即业务逻辑和界面逻辑分离)
 *            2.客户端无需知道所创建的具体产品类的类名，只需要具体产品类所对应的参数即可
 *            3.通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了
 *            系统的灵活性。
 *        2、缺点
 *            1.工厂类集中了所有产品的逻辑，职责过重，一旦不能工作，整个系统都要收到影响
 *            2.增加系统中类的个数，增加了系统的复杂度和理解难度
 *            3.系统扩展困难，一旦添加了新产品不得不修改工厂逻辑。
 *            4.由于使用了静态工厂方法，造成了工厂角色无法基于继承的等级结构，工厂类不能得到很好的扩展
 *        3、适用场景
 *            1.工厂类负责创建的对象比较少，由于创建的对象比较少，不会造成工厂方法中的业务逻辑太过复杂
 *            2.客户端只知道传入工厂类的参数，对于对象是如何创建的并不关心
 *
 *    工厂方法模式优缺点以及应用场景
 *        1、优点：
 *            1.符合开关原则
 *            2.将创建对象的逻辑和任务交给工厂类
 *        2、缺点
 *            1.每次新增产品，产品类都需要创建对应的工厂类，增加了系统的开销
 *        3、适用场景
 *            1.创建某些类的对象的逻辑比较复杂，并且有很多分支条件，而且还可能增加新的条件
 *            2.一个类不知道它所需要的对象的类
 *            3.一个类通过子类来指定创建哪个类
 *            4.需要封装创建类的对象的逻辑，使得这些逻辑局部化
 *
 *     抽象工厂模式优缺点以及应用场景
 *        1、优点：
 *            1.隔离了具体类的生成，使得客户端并不需要知道什么被创建
 *            2.当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象
 *            3.增加新的产品族很方便，无需修改已有系统，符合开闭原则
 *        2、缺点：增加新的产品等级结构麻烦，需要对原有的系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大
 *        的不便，违背了开闭原则
 *        3、适用场景
 *            1.一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节
 *            2.系统中有多于一个的产品族，但每次只使用其中某一产品族
 *            3.属于同一产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来
 *            4.产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构
 *
 *
 *       简单工厂模式：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建出来的实例通常具有共同的父类
 *       工厂方法模式：定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化，工厂方法模式让一个类的实例化延迟
 *       到其子类
 *       抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口。而无需指定它们具体的类
 *
 *    原型模式
 *        1、基本介绍：
 *            1.原型模式是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
 *            2.原型模式是一种创建型设计模式，允许一个对象再创建另一个可定制的对象，无需知道如何创建的细节
 *            3.工作原理是通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们
 *            自己来实施创建，即对象.clone()
 *        2、注意事项和细节
 *            1.创建新的对象比较复杂时，可以使用原型模式简化对象的创建过程，同时也能够提高效率
 *            2.不用重新初始化对象，而是动态地获得对象运行时的状态
 *            3.如果原始对象发生变化(增加或者减少属性)，其他克隆对象的也会发生相应的变化，无需修改代码
 *            4.在实现深克隆的时候可能比较复杂
 *            5.缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改
 *            其源代码，违背了开闭原则
 *
 *    浅拷贝和深拷贝
 *        浅拷贝：
 *            1、对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
 *            2、对于数据类型是引用类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是
 *            只是将该成员变量的引用值(内存地址)复制一份给新的对象，因此实际上两个对象的该成员变量都指向同一个实例，在这种情况下，
 *            在一个对象中修改该成员变量会影响到另一个成员变量值。
 *            3、浅拷贝是使用默认clone方法来实现的
 *        深拷贝：
 *            1、复制对象的所有基本数据类型的成员变量值
 *            2、为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象，也就是说
 *            对象进行深拷贝要对整个对象进行拷贝
 *            3、重写clone方法实现深拷贝
 *            4、通过对象序列化实现深拷贝
 *    原型模式应用场景：
 *        1、当我们的类初始化需要消耗很多资源时，就可以使用原型模式，因为我们的克隆不会执行构造方法，避免了初始化占有的时间和空间。
 *        2、一个对象被其他对象访问，并且能够修改时，访问权限都无效了，什么都能修改
 *        3、访问权限对原型模式无效
 *                原理也很简单，我们是从内存中直接复制的，所以克隆起来也会直接无视，复制相应的内容就好了。
 *
 *    建造者模式
 *      基本介绍：
 *          1、建造者模式又叫生成器模式，是一种对象构建模式，它可以将复杂对象的建造过程抽象出来(抽象类别)，使这个抽象过程
 *          的不同实现方法可以构造出不同表现(属性)的对象
 *          2、建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建他们，用户
 *          不需要知道内部的具体构建细节
 *      建造者模式的四个角色
 *          1、Product（产品角色）：一个具体的产品对象
 *          2、Builder（抽象建造者）：创建一个Product对象的各个部件指定的接口/抽象类
 *          3、ConcreteBuilder（具体创建者）：实现接口，构建和装配各个部件
 *          4、Director（指挥者）：构建一个使用Builder接口的对象，它主要是用于创建一个复杂的对象。它主要有两个作用，
 *          一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。
 *      建造者模式的注意事项和细节
 *          1、客户端不必知道产品内部组成的细节，将产品本身和产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
 *          2、每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者
 *          用户使用不同的具体建造者即可得到不同的产品对象
 *          3、可以更加精细地控制产品的创建过程，将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更
 *          方便使用程序来控制创建过程
 *          4、增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造类编程，系统扩展方便，符合开闭原则
 *          5、建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用
 *          建造者模式，因此其使用范围受到一定的限制
 *          6、如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种
 *          情况下，要考虑是否选择建造者模式
 *      建造者模式和抽象工厂模式
 *          抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品:具有不同分类维度的产品组合，采用抽象工厂
 *          模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的
 *          主要目的是通过组装零配件而产生一个新产品。
 *     建造者模式的使用场景：
 *          1、隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果
 *          2、多个部件都可以装配到一个对象中，但产生的结果不同
 *          3、产品类非常复杂或者产品类因为调用顺序不同而产生不同的作用
 *          4、初始化一个对象时，参数过多，或者很多参数具有默认值
 *          5、需要生产的产品对象有复杂的内部结构，这些产品对象具有共性。
 *
 *  适配器模式
 *      基本介绍：
 *          1、适配器模式将某个类的接口转换成客户端期望的另一个接口表示，主要目的是兼容性，让原本因接口不匹配
 *          不能一起工作的两个类可以协同工作，其别名为包装器
 *          2、适配器模式属于结构型模式
 *          3、主要分为三类：类适配器模式、对象适配器模式、接口适配器模式
 *      工作原理：
 *          1、适配器模式将一个类的接口转换成另一个接口，让原本接口不兼容的类可以兼容
 *          2、从用户的角度看不到被适配者，是解耦的
 *          3、用户调用适配转换出来的目标接口方法，适配器再调用被适配者的相关接口方法
 *          4、用户收到反馈结果，感觉只是和目标接口交互
 *      适用场景：
 *          1、系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码
 *          2、想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作
 *
 *   类适配器模式的注意事项和细节
 *      1、Java是单继承机制，所以类适配器需要继承是src类这一点算是一个缺点，因为这要求dst必须是接口
 *      2、src类的方法在Adapter中都会暴露出来，也增加了使用的成本
 *      3、由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强
 *   对象适配器模式
 *      基本介绍：
 *          1、根据合成复用原则，在系统中尽量使用关联关系来替代继承关系
 *          2、对象适配器模式是适配器模式常用的一种
 *      对象适配器注意事项和细节
 *          1、对象适配器和类适配器其实算是同一种思想，只不过实现方式不同，根据合成复用原则，使用组合替代继承，
 *          所以它解决了类适配器必须继承src的局限性问题，也不再要求dst必须是接口
 *          2、使用成本更低、更灵活
 *   接口适配器模式：
 *      基本介绍：
 *          1、接口适配器模式又叫缺省适配器模式
 *          2、当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现方法（空方法）
 *          那么该子类可有选择地覆盖父类某些方法来实现需求
 *          3、适用于一个接口不想使用其所有方法的情况
 *
 *  桥接模式：
 *      基本介绍：
 *          1、桥接模式是指将现实和抽象放在两个不同的类层次中，使两个层次可以独立改变
 *          2、是一个结构型设计模式
 *          3、桥接模式基于类的最小设计模式，通过使用封装、聚合及继承等行为让不同的类承担不同的职责，它的主要特点
 *          是把抽象与行为实现分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展
 *      注意事项和细节
 *          1、实现了抽象和实现部分的分离，从而极大地提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统
 *          进行分层设计，从而产生更好的结构化系统。
 *          2、对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其他的部分由具体业务来完成
 *          3、桥接模式替代多层继承方案，可以减少子类的个数，减低系统管理和维护成本
 *          4、桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程
 *          5、桥接模式要求正确识别出系统中独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景
 *      适用场景：
 *          对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统。交接模式尤为适用
 *          例：
 *              JDBC驱动程序
 *              银行转账系统：
 *                  转账分类：网上转账、柜台转账、ATM转账
 *                  转账用户类型：普通用户、银行用户、金卡用户
 *              消息管理
 *                  消息类型：即时消息、延时消息
 *                  消息分类：手机消息、邮件消息
 *
 *  装饰者模式
 *      定义：
 *          动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则
 *      适用场景：
 *          1、扩展一个类的功能或者给一个类附加职责
 *          2、给一个对象动态添加功能或动态撤销功能
 *
 *  组合模式
 *      基本介绍：
 *          1、组合模式又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树形结构以表示“整体-部分”的层次关系
 *          2、组合模式依据树形结构来组合对象，用来表示部分和整体层次
 *          3、这种类型的设计模式属于结构型模式
 *          4、组合模式使得用户对单个对象和组合对象的访问具有一致性，即组合能让客户以一致的方式处理个别对象以及组合对象
 *      解决问题：
 *          组合模式解决这样的问题，当我们要处理的对象可以生成一棵树形结构，而我们要对树上的节点和叶子进行操作时，
 *          它能够提供一致的方式，而不用考虑它是节点还是叶子
 *      注意事项和细节：
 *          1、简化客户端操作，客户端只需要面对一直的对象而不用考虑整体部分或者叶子的问题
 *          2、具有较强的扩展性，当我们要更改对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动
 *          3、方便创建出复杂的层次结构，客户端不用理会组合里面的细节，容易添加节点或者叶子从而创建出复杂的属性结构
 *          4、需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式
 *          5、要求较高的抽象性，如果节点和叶子有很大的差异性的话，比如很多方法和属性都不一样，不适合是使用组合模式
 *      组合模式原理结构
 *          1、Component：这是组合中对象声明接口，在适当的情况下，实现所有类共同的接口默认行为，用于访问管理所有的
 *          Component子部件，Component可以是抽象类也可以是接口
 *          2、Leaf：在组合中表示叶子节点，叶子节点没有子节点
 *          3、Composite：非叶子结点，存储子节点，在Component接口中实现子部件的相关操作，比如增加，删除
 *
 *  外观模式
 *      基本介绍：
 *          1、外观模式也叫过程模式，外观模式为子系统中一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口
 *          使得这一子系统更加容易使用
 *          2、外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需要跟这个接口发生调用，而无需
 *          关心这个子系统的内部细节
 *      注意事项和细节：
 *          1、外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性
 *          2、外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展。
 *          3、通过合理的使用外观模式，可以帮我们更好的划分访问的层次
 *          4、当系统需要进行分层设计时，可以考虑使用Facade（外观模式）
 *          5、在维护一个遗留的大型系统时，可能这个系统已经变得难以维护和扩展，此时，可以考虑为新系统开发一个Facade类
 *          来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性
 *          6、不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好，要以系统有层次，利于
 *          维护为目的。
 *      原理、角色说明
 *          1、外观类（Facade）：为调用端提供一个统一的调用接口，外观类知道哪些子系统负责处理请求，从而将调用端的
 *          请求代理给子系统对象
 *          2、调用者（client）：外观接口的调用者
 *          3、子系统的集合：指模块或者子系统，处理Facade对象指派的任务，它是功能的实际提供者
 *
 *  享元模式
 *      基本介绍：
 *          1、享元模式（Flyweight Pattern）也叫蝇量模式，运用共享技术有效地支持大量细粒度的对象
 *          2、常用于系统底层开发，解决系统的性能问题，像数据库连接池，里面都是创建好的连接对象，在这些连接对象中
 *          有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个
 *          3、享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似的对象，需要缓冲池时，不需要总是创建新对象
 *          可以从缓存池里拿，这样可以降低系统内存，同时提高效率
 *          4、享元模式典型的应用场景就是线程池技术、String常量池、数据库连接池、缓冲池等等都是享元模式的应用，
 *          享元模式是池技术的重要实现方式
 *      原理结构说明：
 *          1、Flyweight是抽象的享元角色，它是产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现类
 *          2、ConcreteFlyweight是具体的享元角色，是具体的产品类，实现抽象角色定义相关方法
 *          3、UnShareConcreteFlyweight是不可共享的角色，一般不会出现在享元工厂里
 *          4、FlyweightFactory享元工厂类，用于构建一个池容器，同时提供从池中获取对象方法
 *      享元模式提出两个要求：细粒度和共享对象，即将对象分为两个部分：内部状态和外部状态
 *          1、内部状态：指对象共享出来的信息，存储在享元对象内部而且不会随环境的改变而改变
 *          2、外部状态：指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态
 *      享元模式的注意事项和细节
 *          1、在享元模式这样理解，享代表共享，元代表对象
 *          2、系统中有大量的对象，这些对象消耗大量的内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用
 *          享元模式
 *          3、用唯一标识码判断，如果内存中有，则返回这个唯一标识的对象，用集合存储
 *          4、享元模式大大减少了对象的创建，减低了程序中内存的占用，提高效率
 *          5、享元模式提高了系统的复杂度，需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部系统
 *          状态的改变而改变，这是我们使用享元模式需要注意的地方
 *          6、使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制
 *          7、享元模式经典应用场景是需要缓冲池的场景，比如String常量池、数据库连接池等
 *
 *  代理模式
 *      基本介绍：
 *          1、代理模式（Proxy）为对象提供一个替身，以控制对这个对象的访问，即通过代理对象访问目标对象，这样做的
 *          好处是：可以在目标对象的基础上，增强额外的功能操作，即扩展目标对象的功能
 *          2、被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象
 *          3、代理模式有不同的形式，主要有三种静态代理、动态代理和Cglib代理（可以在内存中动态的创建对象，而不需要实现接口）
 *      静态代理
 *          静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或者继承
 *          相同的父类
 *          静态代理的优缺点：
 *              1、优点：在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展
 *              2、缺点；因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类
 *              3、一旦接口增加方法，目标对象与代理对象都要维护
 *      动态代理
 *          基本介绍：
 *              1、代理对象不需要实现接口，但是目标对象要实现接口，否则不能用动态代理
 *              2、代理对象的生成是利用JDK的API动态在内存中构建代理对象
 *      Cglib代理
 *          基本介绍：
 *              1、静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是单独的对象，并没有实现
 *              任何的接口，这个时候可使用目标对象子类来实现代理，这就是Cglib代理
 *              2、Cglib代理也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能扩展
 *              3、Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展java类与实现java接口，它广泛的被许多
 *              AOP的框架使用，实现方法拦截
 *              4、在AOP中如何选择代理模式
 *                  1.目标对象需要实现接口，用JDK代理
 *                  2.目标对象不需要实现接口，用Cglib代理
 *              5、Cglib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类
 *              6、如果目标对象的方法是final和static修饰的，不会被拦截，即不会执行目标对象额外的业务方法
 *
 *  模板模式
 *      基本介绍：
 *          1、模板模式（Template Pattern）又叫模板方法模式，在一个抽象类中公开定义了执行它的方法的模板，它的子类
 *          可以按需要重写方法实现，但调用将以抽象类中定义的方式进行
 *          2、简单说，模板方法模式定义了一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个
 *          算法的结构，就可以重定义该算法的某些特定步骤
 *          3、这种类型的设计模式属于行为型设计模式
 *      原理结构说明：
 *          AbstractClass：抽象类，类中实现了模板方法，定义了算法的骨架，具体子类需要去实现其他的抽象方法
 *          ConcreteClass：实现抽象方法，以完成算法中特点子类的步骤
 *      模板模式的钩子方法
 *          在模板模式的父类中，我们可以定义一个方法，它默认是不做任何事的，子类可以视情况而定要不要覆盖它，该方法称为钩子
 *      模板方法模式的注意事项和细节
 *          1、基本思想是算法只存在于一个地方，也就是父类中，容易修改，需要修改算法时，只要修改父类的模板方法或者已经实现
 *          的某些步骤，子类就会继承这些修改
 *          2、实现了最大代码复用，父类的模板方法和已实现的某些步骤会被子类继承而直接使用
 *          3、既统一了算法，也提供了很大的灵活性，父类的模板方法确保了算法的结构保持不变，同时由于类提供部分步骤
 *          的实现
 *          4、该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大
 *          5、一般的模板方法都会加上final关键字，防止子类重写模板方法
 *          6、模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤基本相同，但其个别
 *          步骤实现时可能不同，通常考虑用模板方法模式来处理
 *
 *  命令模式
 *      基本介绍：
 *          1、命令模式（Command Pattern），在软件设计中，我们经常需要向某些对象发送请求，但是不知道请求的接收者
 *          是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式
 *          进行设计
 *          2、命令模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加的灵活，实现解耦
 *          3、在命令模式中，会将一个请求封装为一个对象，以便使用不同的参数来表示不同的请求，（即命令）同时命令
 *          模式也支持撤销的操作
 *          4、实例：将军发布命令，士兵去执行
 *              Invoker是调用者（将军）
 *              ConcreteCommand是命令，实现了Command接口，持有接收对象，将一个接收者与一个动作，调用接收者相应的
 *              的操作，实现execute
 *              Command：是命令角色，需要执行的所有命令都在这里，可以是抽象类或者接口
 *              Receiver是被调用者（士兵）,是接收者角色，知道如何实施和执行一个请求相关的操作
 *      注意事项和细节
 *          1、将发起请求的对象和执行请求的对象解耦，发起请求的对象是调用者，调用者只要调用命令的execute（）方法就可
 *          以让接收者工作，而不必知道具体的接收者对象是谁、如何实现的，命令对象负责让接收者执行请求的动作，也就是说
 *          请求发起者和请求执行者之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用
 *          2、容易设计一个命令队列，只要把命令对象放到队列，就可以多线程的执行命令
 *          3、容易实现对请求的撤销和重做
 *          4、命令模式的不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在使用的时候注意
 *          5、空命令也是一种命令模式，它为我们省去了判空的操作，在上面实例中，如果没有用空命令，我们每按下一个按键
 *          都需要判空，
 *          6、命令模式的经典的应用场景；界面的一个按钮都是一条命令、模拟CMD、订单的撤销/恢复、触发-反馈机制
 *
 *  访问者模式
 *      基本介绍：
 *          1、访问者模式(Visitor Pattern)，封装一些作用于某些数据机构的各元素的操作，它可以在不改变数据结构的前提下定义
 *          作用于这些元素的操作
 *          2、主要将数据结构与数据操作分离，解决数据结构和操作的耦合性问题
 *          3、访问者模式的基本工作原理是：在被访问的类里面加一个提供对外提供接待访问者的接口
 *          4、访问者模式的主要应用场景是需要对一个对象结构中的对象进行很多不同操作（这些操作彼此之间没有关联）
 *          同时需要避免让这些操作“污染”这些对象的类，可以选用访问者模式
 *      原理结构说明
 *          1、Visitor是抽象访问者，为该对象结构中的ConcreteElement的每一个类声明一个visit操作
 *          2、ConcreteVisitor是一个具体的访问值，实现每个有Visitor声明的操作，是每个操作实现的部分
 *          3、ObjectStructure能枚举它的元素，可以提供一个高层的接口，用来允许访问者访问元素
 *          4、Element定义一个accept方法，接收一个访问者对象
 *          5、ConcreteElement为具体元素，实现了accept方法
 *      双分派
 *          双分派是指不管类怎么变化，我们都能找到期望的方法运行，双分派意味着得到执行的操作取决于请求的种类和两个
 *          接收者的类型
 *          以实例为例，假设我们需要添加一个Wait的状态类，考查Man类和Woman类的反应，由于使用了双分派，只需要增加
 *          一个Action子类即可在客户端调用即可，不需要改动其他类的代码
 *      访问者模式的优缺点
 *          优点：
 *              1、访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高
 *              2、访问者模式可以对功能进行统一，可以做报表、UI、拦截器和过滤器，使用于数据结构相对稳定的系统
 *          缺点：
 *              1、具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则不建议的，
 *              这样造成了具体元素变更比较困难
 *              2、违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素
 *              3、因此，如果一个系统有比较稳定的数据结构，有经常变化的功能需求，那么访问者模式就是比较合适的。
 *
 *  迭代器模式
 *      基本介绍：
 *          1、迭代器模式（Iterator Pattern）是常用的设计模式，属于行为型设计模式
 *          2、如果我们的集合元素是用不同的方式实现的，有数组，还有java的集合类，或者还有其他的方式，当客户端
 *          要遍历这些集合元素的时候就要使用多种遍历的方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式
 *          解决
 *          3、迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历元素，不需要知道结合对象的底层表示，
 *          即不暴露其内部的结构
 *      原理结构说明：
 *          1、Iterator：迭代器接口，是系统提供，含有hasNext、next、remove
 *          2、ConcreteIterator：具体的迭代器类，管理迭代
 *          3、Aggregate：一个统一的聚合接口，将客户端和具体聚合解耦
 *          4、ConcreteAggregate：具体的聚合持有对象集合，并提供一个方法吗，返回一个迭代器，该迭代器可以正确
 *          遍历集合
 *          5、Client：客户端，通过Iterator和Aggregate依赖子类
 *
 *      迭代器模式解决了不同集合统一遍历问题
 *
 *      迭代器的优缺点;
 *          优点：
 *              1、提供一个统一的方法遍历对象，客户不用再考虑聚合的类型，使用一种方法就可以遍历对象了
 *              2、隐藏了聚合的内部结构，客户端要遍历聚合的时候只能取到迭代器，而不会知道聚合的具体组成
 *              3、提供了一种设计思想，就是把一个类应该只有一个引起变化的原因（叫做单一职责原则），在聚合类中
 *              ，我们把迭代器分开，就是要把管理对象集合和比遍历对象集合的责任分开，这样一来集合改变的话，只能
 *              影响聚合对象，而如果遍历方式改变的话，只能影响到迭代器
 *              4、当要展示一组相似对象，或者遍历一组相同对象时使用，适合使用迭代器模式
 *          缺点：
 *              每个聚合对象都要一个迭代器，会生成对个迭代器不好管理类
 *
 *  观察者模式（Observer）原理
 *      1、气象局：Subject
 *      2、用户、第三方网站：Observer，接收输入
 *      Subject：登记注册、移除和通知
 *          1、registerObserver：注册
 *          2、removeObserver：移除
 *          3、notifyObserver：通知所有的注册的用户，根据不同需求，可以是更新数据，让用户来取，也可能是实时推送
 *      观察者模式：对象之间是多对一依赖的一种设计方案，被依赖的对象是Subject，依赖的对象是Observer，Subject
 *      通知Observer变化，比如这里的气象局是Subject，是1的一方，用户是Observer是多的一方
 *      观察者模式的好处；
 *          1、观察者模式设计后，会以集合的方式来管理用户（Observer），包括注册，移除和通知
 *          2、这样，我们增加观察者的时候就不需要去修改核心类WeatherData不会修改代码，遵守OCP原则
 *      当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象有待改变的时候，应该考虑使用观察者模式。
 * 　　 而使用观察者模式的动机在于：将一个系统分割成一系列相互协作的类有一个很不好的副作用，就是需要维护相关对象间
 *      的一致性，我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便，而观察者模式所做的
 *      工作就是在解除耦合。
 *
 *  中介者模式
 *      基本介绍：
 *          1、中介者模式（Mediator Pattern）用一个中介对象来封装以一系列的对象交互。中介者使各个对象不需要显示地
 *          相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互
 *          2、中介者模式属于行为型模式，使代码易于维护
 *          3、比如MVC模式，C（Controller）是M（Model）和V(View)的中介者，在前后端交互起到了中间人的作用
 *      原理图结构说明
 *          1、Mediator就是抽象中介者，定义了同事对象到中介者对象的接口
 *          2、ConcreteMediator具体的中介者对象，实现了抽象方法，需要知道具体的同事类，即以一个集合来管理，并接收
 *          某个同事对象的消息，完成相应的任务
 *          3、Colleague是抽象同事类
 *          4、ConcreteColleague是具体的同事类，每个同事只知道自己的行为，而不了解其它同事的行为，但是他们都依赖中
 *          介者对象
 *      中介者模式的注意事项和细节
 *          1、多个类相互耦合，会形成网状结构，使用中介者模式将网状结构分离星型结构，进行解耦
 *          2、减少类间的依赖，降低了耦合，符合迪米特原则
 *          3、中介者承担了较多的责任，一旦中介者出现问题，整个系统就会受到影响
 *          4、如果设计不当，中介者对象本身变得过于复杂，这点在实际使用中，需要特别注意
 *      中介者模式的应用场景和优缺点
 *          1、系统中对象存在较为复杂引用，导致依赖关系和结构混乱而无法复用的情况
 *          2、想通过一个中间类来封装多个类的行为，但是有不想要太多的子类
 *          优点；
 *              1、松散耦合、将多个对象之间的联系紧耦合封装到中介对象中，做到松耦合，不会导致一动牵全身
 *              2、将多个对象之间的交互联系集中到中介者对象中，发送变化仅需修改中介者对象即可、提供系统的灵活性、
 *              使同事对象独立而易于复用
 *              3、符合迪米特法则，一个对象应当对其他对象尽可能少的了解，减少各个对象之间的了解
 *          缺点；
 *              如果各个对象间的交互非常多并且复杂的情况下，都交给中介者会导致中介者变得十分复杂，不易维护和管理
 *
 *  备忘录模式
 *      基本介绍：
 *          1、备忘录模式（Memento pattern）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，
 *          这样之后就可将该对象恢复到原先保存的状态了
 *          2、备忘录对象主要用来记录一个对象的某种状态或者某些数据，当要做回退时，可以从备忘录对象里获取到原来的数据
 *          进行恢复操作
 *          3、备忘录模式属于行为型模式
 *      注意事项和细节
 *          1、给用户提供一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态
 *          2、实现了信息的封装，使得用户不需要关心状态的保存细节
 *          3、如果类成员的变量过多，势必会占用较大的资源，而且每一次保存都会消耗一定的内存
 *          4、使用场景：后悔药、打游戏的存档、事务管理、Windows的Ctrl+Z、IE的后退
 *          5、为了节约内存，备忘录模式可以和原型模式配合使用
 *
 *  解释器模式
 *      基本介绍：
 *          1、在编译原理中，一个算术表达式通过词法分析器形成词法单元，而后这些词法单元在通过语法分析器构建语法分析树，
 *          最终形成一棵抽象的语法分析树，这里的词法分析器和语法分析器都可以看做是解释器
 *          2、解释器模式（Interpreter Pattern）是指给定一个语言（表达式），定义它的文法的一种表示，使用该解释器来解释
 *          语言中的句子
 *          3、应用场景；
 *              * 应用可以将一个需要解释执行的语言中的句子表示为一个抽象语法树
 *              * 一些重复出现的问题可以用一种简单的语言来表达
 *              * 一些简单语法需要解释的场景
 *          4、编译器、运算表达式计算、正则表达式、机器人
 *      原理结构分析
 *          1、Context；是环境角色，含有解释器之外的全局信息
 *          2、AbstractExpression：抽象表达式，声明一个抽象的解释操作。这个方法为抽象语法树中所有的节点所共享
 *          3、TerminalExpression：为终结符表达式，实现与文法中的终结符相关的解释操作
 *          4、NonTerminalExpression：为非终结符表达式，为文法中的非终结符实现解释操作
 *      解释器的设计模式和细节
 *          1、当有一个语言需要解释执行，可将该语言中的句子表示为一个抽象语法树，就可考虑使用解释着模式，让程序具有
 *          良好的扩展性
 *          2、应用场景；编译器、运算表达式计算、正则表达式
 *          3、使用解释器可能带来的问题：解释器模式会引起类膨胀、解释器模式采用递归调用的方法，将会导致调试非常
 *          复杂、效率可能降低
 *
 *  状态模式
 *      基本介绍；
 *          1、状态模式（State Pattern）：它主要是用来解决对象在多种状态装换时，需要对外输出不同行为的问题，状态
 *          和行为是一一对应的，状态之间相互装换
 *          2、当一个对象的内在状态改变时，允许其行为，这个对象看起来像是改变了其类
 *      原理结构说明：
 *          1、Context类是环境角色。用于维护State实例，这个实例定义当前状态
 *          2、State是抽象状态角色，定义一个接口封装与Context的一个特定接口的相关行为
 *          3、ConcreteState具体的状态角色，每个子类实现一个与Context的一个状态相关行为
 *      状态模式的注意事项和细节
 *          1、代码有很强的可读性，状态模式将每个状态的行为封装到对应的一个类中
 *          2、方便维护，将容易产生的问题的if-else语句删除了，如果把每个状态的行为都放到一个类中，每次调用方法时，
 *          都要判断当前是什么状态，不但会产生很多if-else语句，容易出错
 *          3、符合开闭原则，容易增删状态
 *          4、会产生很多类，每个状态都要一个对应的类，当状态过多时会产生很多类，加大维护难度
 *          5、当一个事件或者对象有很多状态，状态之间会相互转换，对不同的状态要求有不同的行动的时候，可以考虑使用
 *          状态模式
 *
 *  策略模式
 *      基本介绍：
 *          1、策略模式（Strategy Pattern）中，定义算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化
 *          独立于使用算法的客户
 *          2、这算法体现了几个设计原则，第一、把变化的代码从不变的代码中分离出来，第二、针对接口编程而不是具体类（定义策略接口）
 *          第三、多用组合/聚合，少用继承（客户通过组合方式使用策略）
 *      注意事项和细节
 *          1、策略模式的关键是；分析项目中变化部分和不变部分
 *          2、策略模式的核心思想是：多用组合/聚合，少用继承，用行为类组合，而不是行为的继承，更具有弹性
 *          3、体现了开闭原则，客户端增加行为不用修改原有的代码，只要添加一种策略或者行为即可，避免了使用多重转移
 *          语句（if-else）
 *          4、提供了可以替换继承关系的方法，策略模式将算法封装在独立的Strategy类中，使得你可以独立于其Context改变它
 *          ，使它易于切换、易于理解、易于扩展
 *          5、每添加一个策略就要增加一个类，当策略过多是会导致类数目庞大的
 *      与状态模式的区别
 *          策略模式只是条件选择方法，只执行一次方法，而状态模式是随着状态的改变不停的更改执行方法。
 *          实例；旅游，对于策略模式，只需要选择其中一种出行方式，但是状态模式需要根据不同的状态选择不同的出行方式
 *
 *  职责链模式
 *      基本介绍：
 *          1、职责链模式（Chain of Responsibility Pattern）又叫责任链模式，为请求创建一个接收者对象的链，这种模式对请求的
 *          发送者和接收者进行解耦
 *          2、职责链模式通常每个接收者都包含对另一个接收者的引用，如果一个对象不能处理该请求，那么它会把相同的请求传给
 *          下一个接收者。
 *          3、这种类型的设计模式属于行为型模式
 *          4、职责链模式是多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这个对象连成一条
 *          链，并沿着这条链传递该请求，直到有一个对象处理它为止
 *      原理结构说明：
 *          1、Handler：抽象的处理者，定义了一个处理请求的接口，同时含义另外Handler
 *          2、ConcreteHandlerA、B是具体的处理者，处理它自己负责的请求，可以访问它的下一个处理者，如果可以处理当前
 *          请求，则处理，否则就将该请求交给下一个处理者处理，从而形成一个职责链
 *          3、Request，含有很多属性，表示一个请求
 *      注意事项和细节；
 *          1、将请求和处理分开，实现解耦，提高了系统的灵活性
 *          2、简化了对象，使对象不需要知道链的结构
 *          3、性能会受到影响，特别是在链比较长的时候，因此需控制链中最大节点数量，一般通过在Handler中设置一个最大
 *          节点数量，在setNext()方法中判断是否已经超过阈值，超过则不允许该链建立，避免出现超长链无意识地破坏系统
 *          性能。
 *          4、调试不方便，采用了类似递归的方法，调试时逻辑可能比较复杂
 *          5、最佳应用场景：有多个对象可以处理同一个请求时，比如：多级请求、请假/加薪等审批流程、JavaWeb中Tomcat
 *          对Encoding的处理器、拦截器
 *
 */
public class Patterns {
}
